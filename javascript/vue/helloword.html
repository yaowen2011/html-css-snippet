<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>vue.js-helloworld</title>
	<style>
		html, body {
			text-align:center;
		}
		
	</style>
	<script src="./vue.js"></script>
	
</head>
<body>
	<div id="example"></div>
	<!-- 参考文档 https://cn.vuejs.org/v2/guide/#Vue-js-是什么 -->
	<div id="app">
		{{ message }}
	</div>
	
	<div id="app-2">
		<span v-bind:title="message">
			鼠标悬停几秒钟查看此处动态绑定的提示信息！
		</span>
	</div>

	<div id="app-3">
		<p v-if="seen">
			通过设置seen的bool属性 切换显示
		</p>
	</div>

	<div id="app-4">
		<ol>
			<li v-for="todo in todoList">
				{{todo.text}}
			</li>
		</ol>
	</div>

	<div id="app-5">
		<p>{{ message }}</p>
		<button v-on:click="reverseMessage">逆转信息</button>
	</div>

	<div id="app-6">
		<p>{{message}}</p>
		<input v-model="message" type="text">
	</div>

	<div id="app-7">
		<ol>
			<todo-item v-for="item in fruitList" v-bind:todo="item" v-bind:key="item.id">
			</todo-item>	
		</ol>
	</div>
	<script>
	    // window.onload = function() {
			var app = new Vue({
				el: '#app',
				data: {
					message: 'Hello Vue'
				}

			});
	        
	        //你看到的 v-bind 属性被称为指令。指令带有前缀 v-，以表示它们是 Vue 提供的特殊属性。
	        // 简言之，这里该指令的作用是：“将这个元素节点的 title 属性和 Vue 实例的 message 属性保持一致”。
	        // 再次打开浏览器的 JavaScript 控制台输入 app2.message = '新消息'，就会再一次看到这个绑定了 title 属性的 HTML 已经进行了更新。
	        var app2 = new Vue({
	        	el: '#app-2',
	        	data: {
	        		message: '页面加载于' + new Date()
	        	}
	        });

	        //v-if 带有轻微的 逻辑性  直接操作了  display:none
	        //这个例子演示了我们不仅可以绑定 DOM 文本到数据，也可以绑定 DOM 结构到数据。
	        // 有点没懂 这个词
	        var app3 = new Vue({
	        	el: '#app-3',
	        	data: {
	        		seen:true
	        	}
	        });

	        //演示指令 v-for
	        // 在控制台里，输入 app4.todos.push({ text: '新项目' })，你会发现列表中添加了一个新项。
	        var app4 = new Vue({
	        	el: '#app-4',
	        	data: {
	        		todoList: [
	        			{text: "学习vue"},
	        			{text: "学习前端开发"},
	        			{text: "学习javascript"}
	        		]
	        	}
	        });


	        var app5 = new Vue({
	        	el: '#app-5',
	        	data: {
	        		message: '我要显示的message文本'
	        	},
	        	methods: {
	        		reverseMessage: function() {
	        			this.message = this.message.split('').reverse().join('');
	        		}
	        	}
	        });

	        //Vue 还提供了 v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定。
	        var app6 = new Vue({
	        	el: '#app-6',
	        	data: {
	        		message: '和表单输入绑定'
	        	}
	        });

	        //=========================
	        // Vue组件示例
	        //=========================

	        //step 1: 注册(全局注册)
	        Vue.component('todo-item', {
	        	props: ['todo'],
	        	template: '<li>{{todo.text}}</li>'
	        });

	        var app7 = new Vue({
	        	el: "#app-7",
	        	data: {
	        		fruitList: [
	        			{id:0, text:'苹果'},
	        			{id:1, text:'香蕉'},
	        			{id:2, text:'车厘子'},
	        		]
	        	}
	        });

	        //这种局部注册的组件才是比较常用的
	  //       var Child = {
			// 	  template: '<div>A custom component!</div>'
			// 	}
			// 	new Vue({
			// 	  // ...
			// 	  components: {
			// 	    // <my-component> 将只在父模板可用
			// 	    'my-component': Child
			// 	  }
			// 	})
			// }

	        //假想 使用了 组件后的html 代码结构样子 

	  //       <div id="app">
			//   <app-nav></app-nav>
			//   <app-view>
			//     <app-sidebar></app-sidebar>
			//     <app-content></app-content>
			//   </app-view>
			// </div>

			//每个 Vue 实例都会代理其 data 对象里所有的属性：


			//除了 data 属性， Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的 data 属性区分
			var data = { a: 1 };
			var vm = new Vue({
			  el: '#example',
			  data: data
			});
			console.log(vm.$data === data); // -> true
			console.log(vm.$el === document.getElementById('example')); // -> true
			// $watch 是一个实例方法
			vm.$watch('a', function (newVal, oldVal) {
			  // 这个回调将在 `vm.a`  改变后调用
			})

			//所谓的钩子 一些事件点，暴露对外的 函数绑定，以执行一些特殊的逻辑 
			//如：created、 mounted、updated、destroyed 等钩子点
			//钩子的 this 指向调用它的 Vue 实例。

			//vm实例生命周期图 https://cn.vuejs.org/v2/guide/instance.html#实例生命周期
			//这张图需要多看几遍
			var vm = new Vue({
			  data: {
			    a: 1
			  },
			  created: function () {
			    // `this` 指向 vm 实例
			    console.log('a is: ' + this.a)
			  }
			});	

			//=================00=====
			//模板部分
			//=========================
// 			在底层的实现上， Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。
// 如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，直接写渲染（render）函数，使用可选的 JSX 语法。
			//指令==========================
			//指令（Directives）是带有 v- 前缀的特殊属性。指令属性的值预期是单个 JavaScript 表达式（v-for 是例外情况，稍后我们再讨论）。
			//
			//v-once 指令
			//<span v-once>这个将不会改变: {{ msg }}</span>

			//{{}}=>会对html符号做过滤
			//v-html =>保留html标签 并且 会忽略解析属性值中的数据绑定

			//v-bind 缩写
			//<a v-bind:href="url"></a>
			//<a :href="url"></a>

			//<a v-on:click="doSomething"></a>
			//<a @click="doSomething"></a>

			//过滤器

			//过滤器方法 定义在filters 属性中

			// new Vue({
			//   // ...
			//   filters: {
			//     capitalize: function (value) {
			//       if (!value) return ''
			//       value = value.toString()
			//       return value.charAt(0).toUpperCase() + value.slice(1)
			//     }
			//   }
			// })

			//使用管道符号触发
			// <!-- in mustaches -->
			// {{ message | capitalize }}


			//计算属性 computed
			//注意 这里的reversedMessage 函数 会作为reversedMessage 的getter方法
			// computed: {
			//     // a computed getter
			//     reversedMessage: function () {
			//       // `this` points to the vm instance
			//       return this.message.split('').reverse().join('')
			//     }
			//   }

			//reversedMessage 对比 <p>Reversed message: "{{ reversedMessage() }}"</p>
			//读属性的性能会好些  不会每次都计算，


			//watch 对比 computed
			//watch的逻辑显然要繁琐很多
			// watch: {
			//     firstName: function (val) {
			//       this.fullName = val + ' ' + this.lastName
			//     },
			//     lastName: function (val) {
			//       this.fullName = this.firstName + ' ' + val
			//     }
			//   }

			//   computed: {
			//     fullName: function () {
			//       return this.firstName + ' ' + this.lastName
			//     }
			//   }

			//计算 setter
			//默认是 只有getter的 


			//=========================
			//表单控件绑定
			//==============================

			//v-model 本质上是个语法糖  负责监听事件并且更新


		// };
	</script>
</body>
</html>
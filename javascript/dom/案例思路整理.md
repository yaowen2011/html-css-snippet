## tab栏切换
```js
  //- 排他法
  //注册事件
  for(var i = 0; i < lis.length; i++) {
    //存储一个下标
    lis[i].index = i;
    lis[i].onmouseover = function () {
      //干掉所有人  仅仅是active这个类清除
      for(var i = 0; i < lis.length; i++) {
        lis[i].className = "tab-item";
        divs[i].className = "main";
      }
      //复活我自己
      this.className = "tab-item active";
      divs[this.index].className = "main selected";
    }
  }
```
## 祝愿墙
```js
// css的定位熟悉  js 随机 修改css的top left 

// 节点的复制
var newTip = tip1.cloneNode(true);
//添加到content中
content.appendChild(newTip);

// 随机
var x = parseInt(Math.random() * 700);
var y = parseInt(Math.random() * 450);
// 点击查看时z-index的累加
```
## select 子元素左移 右移
```js
// 这里的操作直接由剪切效果 
var options = s1.children;
//逐个把options添加到s2中
for(var i = 0; i < options.length; i++) {
  s2.appendChild(options[i]);
  //原因：children动态更新的，appendChild会s1中的元素添加到s2, s1中的元素在减少
  i--;
}
```
## 标签增删改查
```js
  //思路
  //1. 给按钮注册点击事件
  //2. 获取到文本域的内容
  //3. 创建li标签，添加到ul中

  var txt = document.getElementById("txt");
  var btn = document.getElementById("btn");
  var ul = document.getElementById("ul");

  //1. 给btn注册点击事件
  btn.onclick = function () {
    //2. 获取文本域的内容,文本框  获取值都是用value
    var content = txt.value;
    //获取完内容之后，就可以把内容给清空了
    txt.value = "";

    //如果输入的内容为空，不创建li
    if(content.trim() === ""){
      return;
    }


    //3. 创建li标签
    var li = document.createElement("li");
    ul.insertBefore(li, ul.children[0]);
    li.innerText = content;


    //4. 在li添加button
    var button = document.createElement("button");
    button.innerText = "删除";
    li.appendChild(button);
    button.style.float = "right";
    button.onclick = function () {
      ul.removeChild(li);
    }
  }
```
## 随机点名案例
  - 通过配置数值创建节点，点击 随机一个节点  修改随机节点背景色
## 短信验证码案例
```js
  //思路：
    //1. 给btn注册点击事件
    //2. 禁用btn
    //3. 修改btn的内容
    //4. 如果时间变成了0，清除定时器，让btn能点，恢复btn的内容
  var btn = document.getElementById("btn");
  var timer;
  btn.onclick = function () {
    //禁用btn
    var num = 5;
    btn.disabled = true;
    timer = setInterval(function () {
      num--;
      //修改btn的内容
      btn.value = num+"秒之后可以再次发送";

      //如果num<= 0的时候，，清除定时器，让btn能点，恢复btn的内容
      if(num <= 0){
        clearInterval(timer);
        btn.disabled = false;
        btn.value = "再次发送";
      }
    }, 1000);
  }
```
## 机械表案例
  - m.style.transform = "rotate(" + 6 * minutes + "deg)";
  - 关键是rotate旋转角度算法
## 动画函数封装
```js
//封装的函数要独立：可以直接使用。
  //一个元素，只能有一个定时器在跑。。。。。每隔元素之间，定时器互不干扰。
  //参数：
  //1. element:对谁做动画
  //2. target: 移动到哪儿。
  // jq有一个一模一样的animate，用别人
  function animate(element, target, num){

    //把定时器的id存在了当前做动画的元素上。
    clearInterval(element.timer);
    element.timer = setInterval(function () {
      var step = num;
      var leader = element.offsetLeft;

      if(leader < target){
        leader = leader + step;
        element.style.left = leader + "px";
      }else {
        clearInterval(element.timer);
      }
    }, 15);
  }

  // 优化版本二：
  function animate(element, target, num) {
    clearInterval(element.timer);
    element.timer = setInterval(function () {
      var leader = element.offsetLeft;
      //step有正负之分,如果target超过leader，step需要往右跑，正值
      var step = target > leader ? num : -num;


      //够一步，我就跑，不够我就不跑，清除定时器
      var distance = Math.abs(target - leader);
      if (distance >= Math.abs(step)) {
        leader = leader + step;
        element.style.left = leader + "px";
      } else {
        clearInterval(element.timer);
        //不够一步，就不跑了，直接清定时器，手动抱过去
        element.style.left = target + 'px';
      }
    }, 15);
  }
```

## parentNode && offsetParent
  - offsetParent 最近的有定位的父元素
## offsetLeft = left + margin
  - //offsetLeft获取的是当前元素距离offsetParent的真实距离
  - //offsetLeft获取 left+margin
## offset家族 & scroll家族 & client家族

## 京东轮播图

## mouseenter 放大效果
- 
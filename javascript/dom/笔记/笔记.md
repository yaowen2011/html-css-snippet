# 样式操作

## className

```javascript
box.className = "pink";
```

缺点： 如果样式频繁的发生改变，比较麻烦

使用场景：一次性修改多个样式

## style

```javascript
box.style.borderRadius = "50%";
box.style.backgroundColor = "pink";
box.style.width = "200px";
```

缺点：如果一次性需要改很多样式，很麻烦

使用：一次只需要修改一个样式，style更方便， 如果某一个样式需要不停的变化，style更方便。

### document.body

可以获取页面中的body，可以直接使用

【开关灯案例】

【设置一个盒子的大小和和位置】

【百度换肤案例】

【文档框高亮】

【表格隔行变色高亮】

# 节点操作



## 找节点

### 找孩子

+ childNodes:获取的是所有的子节点（包括标签节点、注释节点）
+ children:获取的是所有的子元素（标签）
+ firstChild: 获取第一个孩子节点， `childNodes[0]`
+ firstElementChild:获取的是第一个孩子元素，相当于`children[0]`
+ lastChild: 获取最后一个孩子节点
+ lastElementChild: 获取最后一个孩子元素

### 找兄弟

+ previousSibling : 获取的当前元素的上一个兄弟节点
+ previousElementSibling: 获取当前元素的上一个兄弟元素
+ nextSibling: 获取的当前元素的下一个兄弟节点
+ nextElementSibling: 获取的是当前元素下一个兄弟元素。

### 找父元素

+ parentNode: 获取的是当前元素的父节点， 父元素



### onkeyup与onkeydown

```javascript
//onkeydown:键盘按下事件， 文本框获取的值是上一次
//onkeyup：键盘弹起事件 ,  文本框获取的值是对的
```

【表单校验.html】



## 添加节点

```javascript
//append：追加
//child:孩子
//功能：box把p当成孩子添加到最后面
//参数：需要添加的节点
box.appendChild(p);
```



## 克隆节点

```javascript
//参数：布尔值
	//false:浅复制：只复制标签
	//true:深复制，复制标签和内容
//返回值：克隆出来的节点，克隆出来的节点和原来的节点没有关系了。
div.cloneNode();

```



### 双击事件

```javascript
onclick:单击
ondblclick:双击
```

# BOM
> BOM（Browser Object Model）：浏览器对象模型，提供了一套操作浏览器功能的工具。

 ![1](images\1.png)



BOM包含的内容很多，但是很多东西都不太常用，在BOM中需要大家掌握的就一个东西，那就是***定时器*** 。

## window对象
1. window对象是一个全局对象，也可以说是JavaScript中的顶级对象
2. 像document、alert()、console.log()这些都是window的属性，其实BOM中基本所有的属性和方法都是属性window的。
3. 所有定义在全局作用域中的变量、函数都会变成window对象的属性和方法
4. window对象下的属性和方法调用的时候可以省略window


### window.onload（掌握）

> window.onload事件会在窗体加载完成后执行，通常我们称之为入口函数。

```javascript
window.onload = function(){
	//里面的代码会在窗体加载完成后执行。
	//窗体加载完成包括文档树的加载、还有图片、文件的加载完成。
}
```


如果有图片加载，那么代码一定要写到window.onload里面，否则会出现图片没有加载完成，获取到的宽度和高度不对的情况。

浏览器会对页面的加载做优化，在加载图片的时候，图片的引入会延迟。

思考：一个页面能不能写两个window.onload?

### window.open与window.close(了解)

> window.open() 打开一个窗口

```javascript
//语法：window.open(url, [name], [features]);
//参数1：需要载入的url地址
//参数2：新窗口的名称
	//_self:在当前窗口打开
	//_blank:在新的窗口打开
//参数3：窗口的属性，指定窗口的大小
//返回值：会返回刚刚创建的那个窗口，用于关闭
//示例：
var newWin = window.open("http://www.baidu.com","_blank", "width=300,height=300");

```

> window.close 关闭窗口

```javascript
newWin.close()；//newWin是刚刚创建的那个窗口
window.close();//把当前窗口给关闭了
```

## 定时器（重点）

### 延时定时器
> 延时定时器可以让代码延迟一段时间之后才执行（定时炸弹）

设置延时定时器
```javascript
//语法：setTimeOut(callback, time);
//参数1：回调函数，时间到了就会执行。
//参数2：延时的时间
//返回：定时器的id，用于清除
//示例：
var timer = setTimeOut(function(){
	//1秒后将执行的代码。
}, 1000);

```

清除延时定时器
```javascript
//语法：clearTimeOut(timerId)
//参数：定时器id
//示例：
clearTimeOut(timer);//清除上面定义的定时器

```

### 间歇定时器
> 间歇定时器让定时器每隔一段时间就会执行一次，并且会一直执行，直到清除定时器为止.

设置间歇定时器
```javascript
//语法：var intervalID = setInterval(func, delay);
//参数1：重复执行的函数
//参数2：每次延迟的毫秒数
//返回：定时器的id，用于清除
//示例：
var timer = setInterval(function(){
	//重复执行的代码。
}, 1000);

```

清除间歇定时器
```javascript
//语法：clearInterval(intervalID)
//参数：定时器id
//示例：
clearInterval(timer);//清除上面定义的定时器

```

### 案例
【短信验证码案例.html】
【电子表案例.html】
【机械表案例.html】

## location对象

> location对象也是window的一个属性，location其实对应的就是浏览器中的地址栏。

### 常用属性和方法

> location.href:控制地址栏中的地址

```javascript
location.href = “http://www.baidu.com”;//让页面跳转到百度首页
```

>location.reload()：让页面重新加载

```javascript
location.reload(true);//强制刷新，相当于ctrl+F5
location.reload(false);//刷新，相当于F5
```

>location的其他属性

```javascript
console.log(window.location.hash);//哈希值 其实就是锚点
console.log(window.location.host);//服务器 服务器名+端口号
console.log(window.location.hostname);//服务器名
console.log(window.location.pathname);//路径名
console.log(window.location.port);//端口
console.log(window.location.protocol);//协议
console.log(window.location.search);//参数
```

【案例：定时跳转.html】

## 其他对象
> window.navigator的一些属性可以获取客户端的一些信息

```javascript
//navigator.userAgent：浏览器版本
```

> history对象表示页面的历史

```javascript
//后退：
history.back();
history.go(-1);
//前进：
history.forward();
history.go(1);
```

> screen对象

```javascript
console.log(screen.width);//屏幕的宽度 
console.log(screen.height);//屏幕的高度
console.log(screen.availWidth);//浏览器可占用的宽度
console.log(screen.availHeight);//浏览器可占用的高度
```


# offset系列

> offset系列用于用于获取元素自身的大小和位置，在网页特效中有广泛应用
> offset系列主要有：offsetHeight、offsetWidth、offsetParent、offsetLeft、offsetTop

## offsetHeight与offsetWidth

> offsetHeight与offsetWidth
```javascript
1.	获取的是元素真实的高度和宽度
2.	获取到的是数值类型，方便计算
3.	offsetHeight与offsetWidth是只读属性，不能设置。
```

> style.height与style.width

```javascript
1.	只能获取行内样式
2.	获取到的是字符串类型，需要转换
```

> ***结论***

```javascript
1. 设置宽度高度使用style.width与style.height
2. 获取宽度和高度offsetWidth与offsetHeight
```

## offsetParent

> parentNode和offsetParent

```javascript
1. parentNode始终是父元素
2. offsetParent是离当前元素最近的定位元素(absolute、relative)，如果没有，那就找body
```


## offsetLeft与offsetTop

> offsetLeft: 自身左侧到offsetParent左侧的距离：left + margin-left
> offsetTop:自身顶部到offsetParent顶部的距离 :  top + margin-top

> offsetLeft与offsetTop
```javascript
1.	元素自身与offsetParent真实的距离
2.	获取到的是数值类型，方便计算
3.	只读属性，只能获取，不能设置
```

> style.left与style.top

```javascript
1.	只能获取行内样式
2.	获取到的是字符串，需要转换
3.	可以获取，也可以设置
```

> **结论**

```javascript
获取操作：用offset系列
设置操作：用style.xxx进行设置。
```


 ![1](images\1.png)



# 动画函数封装

```javascript
1. 让一个盒子，点一次能够跑一次
2. 一个盒子，能够自动的跑到400px的地方
	a).判断leader<400才跑，否则清除定时器
	b).一进来，要记得清除定时器，不然会越点越快。
3. 封装成一个函数
	a).把box替换成element
    b).把400替换成target
    c).把timer绑定到element上
4. 封装的函数不会往回跑
	a).修改step，要有正负 var step = target > leader ? 10 : -10;
	b).判断条件修改，当距离大于等于一步的时候，才跑，否则清除定时器，抱过去
```



# 轮播图

## 简单轮播图

```javascript
1.	结构分析
2.	按钮高亮以及排他
3.	移动图片：
	渐渐的移动图片，用到animate函数
```



## 左右焦点图

```javascript
1.	结构分析
2.	左右箭头的显示与隐藏
3.	点击左箭头与右箭头（下标判断）
```



## 无缝轮播图

```javascript
1. 需要添加假图片
2. 真图片与假图片之间互相切换。
```


# 三大家族

## offset家族

> offset系列用于用于获取元素自身的大小和位置，在网页特效中有广泛应用
>
> offset系列主要有：offsetHeight、offsetWidth、offsetParent、offsetLeft、offsetTop



offsetHeight与offsetWidth

1. 获取的是元素真实的高度和宽度
2. 获取到的是数值类型，方便计算
3. offsetHeight与offsetWidth是只读属性，不能设置。

style.height与style.width

1. 只能获取行内样式
2. 获取到的是字符串类型，需要转换



offsetHeight与offsetWidth的构成

​	offsetHeight = height + paddnig + border

​	offsetWidth = width + padding + border

 ![offset](images\offset.png)

## scroll家族

> scroll家族用来获取盒子内容的大小和位置
>
> scroll家族有：scrollWidth、scrollHeight、scrollLeft、scrollTop

1. scrollWidth与scrollHeight是盒子内容的真实的宽度和高度。与和盒子大小无关，仅仅与盒子的内容有关系。
2. scrollTop是盒子内容被滚动条卷去的头部的高度。scrollLeft是盒子内容被滚动条卷去的左侧的宽度。

 ![scroll](images\scroll.png)

onscroll事件，对于有滚动条的盒子，可以使用onscroll注册滚动事件，每滚动一像素，就会触发该事件。

```javascript
var box = doucment.getElementById(“box”);
box.onscroll = function(){
	//事件处理程序
}
```



获取页面被卷去的高度和宽度

> 通常来说，scroll家族用的最多的地方就是用来获取页面被卷去的宽度和高度，非常的常用

页面被卷去的高度和宽度的兼容性封装

```javascript
function scroll() {
    return {
        top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0,
        left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0
    };
}

//如何使用
console.log(scroll().top);//获取页面被卷去的头部的距离
console.log(scroll().left);//获取页面被卷去的左侧的距离
```



## client家族

> client家族用于获取盒子可视区的大小
>
> client家族有clientWidth、clientHeight、clientLeft、clientTop

**如果内容没有超出盒子范围：clientWidth与scrollWidth相同**

 ![client1](images\client1.png)

> 三大家族对比

 ![client](images\client.png)

> clientTop与clientLeft

**clientTop**与**clientLeft** 完全没有用，他们就是borderTop与borderLeft

但是：如果有滚动条，还会包含滚动条的宽度，但是见过滚动条在上边或者左边的？



> onresize事件：onresize事件会在窗口被调整大小的时候发生。

```javascript
window.onresize = function(){
	//事件处理程序
}
```



> client系列一般用来获取页面的可视区宽高

```javascript
function client() {
    return {
        width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0,
        height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0
    };
}

```

【案例-16-获取页面可视区域的宽度和高度.html】

# 缓动函数封装

封装缓动函数

【筋斗云案例.html】

# 事件对象

## 事件对象的概述

> 在触发某个事件的时候，都会产生一个事件对象Event，这个对象中包含所有与事件相关的一些信息，包括触发事件的元素，事件的类型以及其他与事件相关的信息。

鼠标事件触发时，事件对象中会包含鼠标的位置信息。

键盘事件触发时，事件对象中会包含按下的键相关的信息。

```javascript
每一个事件在触发时，都会产生一个事件对象。
你见或者不见，我就在那里，不悲不喜。
你爱或者不爱，爱就在那里，不增不减。
你用或者不用，我都会给你，不离不弃。 
```



## 获取事件对象

> 既然事件对象中存储了这么多的信息，我们首先需要做的就是获取到这个事件对象。获取事件对象的时候，存在浏览器的兼容问题。

【演示：01-获取事件对象.html】



对于现代浏览器，获取事件对象非常的简单，只需要在注册事件的时候，指定一个形参即可。这个形参就是我们想要获取到的事件对象。

```javascript
btn.onclick = function(event){
    //event就是事件对象，里面包含了事件触发时的一些信息。
	console.log(event);
}

```



对于IE678来说，获取事件对象则是另一种方式，在事件里面，通过window.event来获取事件对象

```javascript
btn.onclick = function(){
	//IE678通过window.event获取事件对象
	var event = window.event;
	console.log(event);
}
```



兼容性封装

```javascript
btn.onclick = function(event){
  	//只要用到了事件对象，就要记得处理浏览器兼容性
	event = event || window.event;
}

```



## 事件对象的常用属性

> 事件对象中有很多很多的属性，但是很多属性并不常用。我们经常用到的是***鼠标位置信息*** 和***键盘码***  相关的信息。

【演示-02-事件对象的常用属性.html】



记录了鼠标位置信息的相关属性

```javascript
screenX与screenY：光标相对于屏幕左上角的水平位置与垂直位置。
clientX与clientY：光标相对于可视区左上角的水平位置和垂直位置。
pageX与pageY：光标相对于网页（文档document）左上角的水平位置与垂直位置（推荐使用）
```



记录了键盘码的属性

```javascript
event.keyCode:键盘按下的那个键的键盘码
```



【案例-03-让小天使飞.html】

## 放大镜效果（案例）

> 放大镜在开发中是一个很常见的特效，但是所有的放大镜的实现效果都是一样。

【案例-07-放大镜特效】



mousemove事件：鼠标移动时会触发这个事件。

```javascript
document.onmousemove = function(){
	console.log("鼠标移动事件在触发");  
};
```



获取鼠标在盒子中的位置：

```javascript
var spaceX = getPage(event).x - box.offsetLeft;
var spaceY = getPage(event).y - box.offsetTop;
```



## 拖拽特效

【案例-08-可拖拽的盒子.html】

【案例-09-拖拽效果(登录框).html】



清除选中的文字（不用记）

```javascript
window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();
```

# 注册事件的两种方式

## on+事件名称

> onclick、onmouseover这种on+事件名称的方式注册事件几乎所有的浏览器都支持。



注册事件：

```javascript
box.onclick = function(){
	//事件处理程序	
}
```

移除事件：

```javascript
box.onclick = null;	
```

on+事件名称注册事件的缺点：

同一个元素同一类型的事件，只能注册一个，如果注册了多个，会出现覆盖问题。



## 注册事件的新方式

**addEventListener与removeEventListener**

> 现代浏览器支持的注册事件的新方式，这种方式注册的事件不会出现覆盖问题。

【演示-10-addEventListener与removeEventListener的用法.html】

addEventListener的语法

```javascript
//第一个参数：事件的类型：click mouseover
//第二个参数：函数，监听者，每次点击，这个函数就执行。
//第三个参数：false
addEventListener(type, func, useCapture);
```

<font color="red">tips：如果想要让你注册的事件能够移除，不能使用匿名函数。</font>

```javascript
function fn1() {
    alert("hehe");
}
//如果想让注册的事件能移除，不能用匿名函数。
box.addEventListener("click", fn1, false);
```



removeEventListen的语法

```javascript
//第一个参数：参数类型
//第二个参数：要移除的那个函数
//第三个参数：false
removeEventListener(type, func, useCapture);
```

**attachEvent与detachEvent**

> IE678不支持addEventListener与removeEventListen两个方法，但是支持attachEvent与detachEvnet

【演示-11-attachEvent与detachEvent的用法.html】

attachEvent的用法：

```javascript
//type:事件类型   需要加上on   onclick  onmouseenter
//func:需要执行的那个事件
attachEvent(type, func)
```

detachEvent的用法

```javascript
//type:事件类型   需要加上on   onclick  onmouseenter
//func:需要执行的那个事件
detachEvent(type, func)
```

# 事件流

> 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡。

说白了就是：当我们触发了子元素的某个事件后，父元素对应的事件也会触发。 ![bubble](images\bubble.png)

通常情况，事件冒泡对于我们来说是没有问题的，我们直接不管就行了，但是如果当事件冒泡给我们带来影响的时候，我们需要阻止事件冒泡。

【03-弹出框案例.html】

> 阻止事件冒泡有浏览器兼容性问题

正常浏览器：

```javascript
link.onclick = function (event) {
    event = event || window.event;
    //stop :停止  propagation：传播
    event.stopPropagation();
}
```



## 事件捕获（了解）

> 事件捕获是火狐浏览器提出来的，IE678不支持事件捕获（基本上，我们都是用事件冒泡）
> 事件的处理将从DOM层次的根开始，而不是从触发事件的目标元素开始，事件被从目标元素的所有祖先元素依次往下传递

【04-事件捕获.html】

 ![capture](images\capture.png)

```javascript
//当addEventListener第三个参数为true时，表示事件捕获
arr[i].addEventListener("click", function () {
    console.log(this);
},true);
```



## 事件的三个阶段

1. 事件的捕获阶段
2. 事件的目标阶段（触发自己的事件）
3. 事件的冒泡阶段

 ![three](images\three.png)



事件有三个阶段，首先发生的是捕获阶段，然后是目标阶段，最后才是冒泡阶段，对于捕获和冒泡，我们只能干预其中的一个，通常来说，我们可能会干预事件冒泡阶段，而不去干预事件捕获阶段。



## 常见的事件

> 常见的鼠标事件

onmousedown:鼠标按下事件

onmouseup:鼠标弹起事件

onclick:单击事件

ondblclick：双击事件

onmouseover：鼠标经过事件

onmouseout：鼠标离开事件

onmousemove：鼠标移动事件

onfocus：鼠标获得焦点事件

onblur：鼠标失去焦点事件



> 常见的键盘事件

onkeydown:键盘按下时触发

onkeyup:键盘弹起时触发



> 对于鼠标事件，事件对象中有一系列的XY记录了鼠标的位置信息。而键盘事件中，事件对象有一个event.keyCode属性，记录了按下去的键的键盘码

【05-按esc隐藏弹出框.html】

【06-弹幕效果.html】





